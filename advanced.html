<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Speaker Detection System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .app-title {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(45deg, #00d4ff, #ff0080, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .panel:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #00d4ff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-panel {
            grid-column: span 2;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            align-items: start;
        }

        .btn {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .system-status {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 1.1rem;
            padding: 1rem;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 1rem;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
            animation: pulse 2s infinite;
        }

        .status-indicator.recording {
            background: #4CAF50;
        }

        .status-indicator.error {
            background: #f44336;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .setting-group {
            background: rgba(255, 255, 255, 0.03);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .setting-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #ccc;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00d4ff, #ff0080);
            cursor: pointer;
        }

        .select {
            width: 100%;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 0.9rem;
        }

        .audio-canvas {
            width: 100%;
            height: 250px;
            border-radius: 15px;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .speaker-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .speaker-item.active {
            background: rgba(76, 175, 80, 0.1);
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }

        .speaker-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .speaker-item:hover::before {
            left: 100%;
        }

        .speaker-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .speaker-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            color: white;
            position: relative;
        }

        .speaker-name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-left: 1rem;
        }

        .speaker-controls {
            display: flex;
            gap: 0.5rem;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.8rem;
            border-radius: 8px;
        }

        .intensity-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 0.5rem 0;
            position: relative;
        }

        .intensity-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A, #CDDC39);
            border-radius: 4px;
            transition: width 0.2s ease;
            position: relative;
        }

        .intensity-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .spectral-analysis {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .frequency-band {
            text-align: center;
            padding: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .frequency-label {
            font-size: 0.8rem;
            color: #ccc;
            margin-bottom: 0.25rem;
        }

        .frequency-value {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .transcription-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
            position: relative;
            transition: all 0.3s ease;
        }

        .transcription-item.closest {
            border-left: 4px solid #4CAF50;
            background: rgba(76, 175, 80, 0.05);
        }

        .transcription-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .transcription-speaker {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .transcription-text {
            font-size: 1rem;
            line-height: 1.5;
            margin: 0.5rem 0;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid rgba(255, 255, 255, 0.2);
        }

        .transcription-meta {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #ccc;
        }

        .device-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .device-item:hover {
            background: rgba(255, 255, 255, 0.06);
        }

        .device-item.in-use {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.05);
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .analytics-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .analytics-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00d4ff;
            margin-bottom: 0.25rem;
        }

        .analytics-label {
            font-size: 0.8rem;
            color: #ccc;
        }

        .no-data {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 2rem;
        }

        .advanced-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                padding: 1rem;
            }
            
            .control-panel {
                grid-column: span 1;
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header class="app-header">
        <h1 class="app-title">üéôÔ∏è Advanced Real-Time Speaker Detection System</h1>
    </header>

    <div class="container">
        <div class="control-panel">
            <div class="panel">
                <h2 class="panel-title">üéõÔ∏è System Controls</h2>
                <div id="systemStatus" class="system-status">
                    <span class="status-indicator idle"></span>
                    <span>System Ready</span>
                </div>
                
                <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                    <button id="startBtn" class="btn btn-primary">üöÄ Start Detection</button>
                    <button id="stopBtn" class="btn btn-danger" disabled>‚èπÔ∏è Stop Detection</button>
                    <button id="addMicBtn" class="btn btn-secondary">üé§ Add Microphone</button>
                </div>

                <div class="advanced-controls">
                    <button id="calibrateBtn" class="btn">üéØ Auto Calibrate</button>
                    <button id="exportBtn" class="btn">üíæ Export Data</button>
                    <button id="resetBtn" class="btn">üîÑ Reset System</button>
                </div>
            </div>

            <div class="panel">
                <h2 class="panel-title">‚öôÔ∏è Advanced Settings</h2>
                <div class="settings-grid">
                    <div class="setting-group">
                        <label class="setting-label">Voice Threshold: <span id="vadValue">-40 dB</span></label>
                        <input type="range" id="vadThreshold" class="slider" min="-60" max="-10" value="-40">
                    </div>
                    
                    <div class="setting-group">
                        <label class="setting-label">Sensitivity: <span id="sensitivityValue">5</span></label>
                        <input type="range" id="sensitivity" class="slider" min="1" max="10" value="5">
                    </div>
                    
                    <div class="setting-group">
                        <label class="setting-label">Noise Gate: <span id="noiseGateValue">0.01</span></label>
                        <input type="range" id="noiseGate" class="slider" min="0.001" max="0.1" step="0.001" value="0.01">
                    </div>
                    
                    <div class="setting-group">
                        <label class="setting-label">Language:</label>
                        <select id="language" class="select">
                            <option value="en-US">English (US)</option>
                            <option value="en-GB">English (UK)</option>
                            <option value="es-ES">Spanish</option>
                            <option value="fr-FR">French</option>
                            <option value="de-DE">German</option>
                            <option value="it-IT">Italian</option>
                            <option value="pt-BR">Portuguese</option>
                            <option value="ru-RU">Russian</option>
                            <option value="ja-JP">Japanese</option>
                            <option value="zh-CN">Chinese (Mandarin)</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2 class="panel-title">üìä Real-Time Analytics</h2>
                <div class="analytics-grid">
                    <div class="analytics-card">
                        <div class="analytics-value" id="totalSpeakers">0</div>
                        <div class="analytics-label">Active Speakers</div>
                    </div>
                    <div class="analytics-card">
                        <div class="analytics-value" id="totalTranscriptions">0</div>
                        <div class="analytics-label">Transcriptions</div>
                    </div>
                    <div class="analytics-card">
                        <div class="analytics-value" id="avgVolume">0%</div>
                        <div class="analytics-label">Avg Volume</div>
                    </div>
                    <div class="analytics-card">
                        <div class="analytics-value" id="dominantFreq">0Hz</div>
                        <div class="analytics-label">Dominant Freq</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2 class="panel-title">üéß Audio Devices</h2>
                <div id="devicesList">
                    <div class="no-data">Loading audio devices...</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2 class="panel-title">üìà Audio Visualization</h2>
            <canvas id="audioCanvas" class="audio-canvas" width="800" height="250"></canvas>
        </div>

        <div class="panel">
            <h2 class="panel-title">üéôÔ∏è Active Speakers</h2>
            <div id="speakersList">
                <div class="no-data">No microphones connected</div>
            </div>
        </div>

        <div class="panel">
            <h2 class="panel-title">üí¨ Live Transcriptions</h2>
            <div id="transcriptionsList">
                <div class="no-data">Start speaking to see live transcriptions...</div>
            </div>
        </div>
    </div>

    <script>
        class AdvancedSpeakerDetectionSystem {
            constructor() {
                this.isRecording = false;
                this.audioStreams = new Map();
                this.audioAnalyzers = new Map();
                this.speakers = new Map();
                this.transcriptions = [];
                this.speakerId = 0;
                this.audioContext = null;
                this.vadThreshold = -40;
                this.sensitivity = 5;
                this.noiseGate = 0.01;
                this.processingInterval = null;
                this.availableDevices = [];
                this.currentLanguage = 'en-US';
                
                // Advanced features
                this.speechPatterns = new Map();
                this.frequencyAnalysis = new Map();
                this.speakerProfiles = new Map();
                this.sessionStartTime = null;
                this.audioMetrics = {
                    totalWords: 0,
                    averageVolume: 0,
                    dominantFrequency: 0,
                    speakingTime: new Map()
                };
                
                // Web Speech API
                this.recognition = null;
                this.isTranscribing = false;
                this.transcriptionTimeout = null;
                
                this.initializeSpeechRecognition();
                this.initializeElements();
                this.bindEvents();
                this.loadAudioDevices();
                this.updateSystemStatus('Advanced System Ready');
                this.startAnalyticsUpdate();
            }

            initializeElements() {
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.addMicBtn = document.getElementById('addMicBtn');
                this.calibrateBtn = document.getElementById('calibrateBtn');
                this.exportBtn = document.getElementById('exportBtn');
                this.resetBtn = document.getElementById('resetBtn');
                
                this.speakersList = document.getElementById('speakersList');
                this.transcriptionsList = document.getElementById('transcriptionsList');
                this.devicesList = document.getElementById('devicesList');
                this.audioCanvas = document.getElementById('audioCanvas');
                this.canvasCtx = this.audioCanvas.getContext('2d');
                this.systemStatus = document.getElementById('systemStatus');
                
                // Settings
                this.vadThresholdSlider = document.getElementById('vadThreshold');
                this.vadValue = document.getElementById('vadValue');
                this.sensitivitySlider = document.getElementById('sensitivity');
                this.sensitivityValue = document.getElementById('sensitivityValue');
                this.noiseGateSlider = document.getElementById('noiseGate');
                this.noiseGateValue = document.getElementById('noiseGateValue');
                this.languageSelect = document.getElementById('language');
                
                // Analytics
                this.totalSpeakersEl = document.getElementById('totalSpeakers');
                this.totalTranscriptionsEl = document.getElementById('totalTranscriptions');
                this.avgVolumeEl = document.getElementById('avgVolume');
                this.dominantFreqEl = document.getElementById('dominantFreq');
            }

            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startAdvancedDetection());
                this.stopBtn.addEventListener('click', () => this.stopDetection());
                this.addMicBtn.addEventListener('click', () => this.addMicrophone());
                this.calibrateBtn.addEventListener('click', () => this.autoCalibrate());
                this.exportBtn.addEventListener('click', () => this.exportSessionData());
                this.resetBtn.addEventListener('click', () => this.resetSystem());
                
                // Settings
                this.vadThresholdSlider.addEventListener('input', (e) => {
                    this.vadThreshold = parseInt(e.target.value);
                    this.vadValue.textContent = `${this.vadThreshold} dB`;
                });
                
                this.sensitivitySlider.addEventListener('input', (e) => {
                    this.sensitivity = parseInt(e.target.value);
                    this.sensitivityValue.textContent = e.target.value;
                });

                this.noiseGateSlider.addEventListener('input', (e) => {
                    this.noiseGate = parseFloat(e.target.value);
                    this.noiseGateValue.textContent = e.target.value;
                });

                this.languageSelect.addEventListener('change', (e) => {
                    this.currentLanguage = e.target.value;
                    if (this.recognition && this.isRecording) {
                        this.restartSpeechRecognition();
                    }
                });
            }

            initializeSpeechRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = this.currentLanguage;
                    this.recognition.maxAlternatives = 3;
                    
                    this.recognition.onstart = () => {
                        console.log('Advanced speech recognition started');
                        this.isTranscribing = true;
                        this.updateSystemStatus('üéØ Advanced listening active...');
                    };
                    
                    this.recognition.onresult = (event) => {
                        this.processAdvancedTranscription(event);
                    };
                    
                    this.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                        this.updateSystemStatus(`‚ùå Speech error: ${event.error}`);
                    };
                    
                    this.recognition.onend = () => {
                        if (this.isRecording) {
                            setTimeout(() => {
                                if (this.isRecording) {
                                    this.recognition.start();
                                }
                            }, 100);
                        } else {
                            this.isTranscribing = false;
                        }
                    };
                } else {
                    this.updateSystemStatus('‚ö†Ô∏è Speech recognition not supported');
                }
            }

            async autoCalibrate() {
                if (!this.isRecording) {
                    alert('Please start detection first to calibrate');
                    return;
                }

                this.updateSystemStatus('üéØ Auto-calibrating...');
                
                // Collect 3 seconds of ambient noise data
                const calibrationData = [];
                const calibrationTime = 3000;
                const startTime = Date.now();
                
                const calibrationInterval = setInterval(() => {
                    this.speakers.forEach(speaker => {
                        const analyzer = speaker.analyzer;
                        const dataArray = new Uint8Array(analyzer.fftSize);
                        analyzer.getByteTimeDomainData(dataArray);
                        
                        let rms = 0;
                        for (let i = 0; i < dataArray.length; i++) {
                            const sample = (dataArray[i] - 128) / 128;
                            rms += sample * sample;
                        }
                        rms = Math.sqrt(rms / dataArray.length);
                        const db = rms > 0 ? 20 * Math.log10(rms) : -100;
                        calibrationData.push(db);
                    });
                    
                    if (Date.now() - startTime >= calibrationTime) {
                        clearInterval(calibrationInterval);
                        this.completeCalibration(calibrationData);
                    }
                }, 50);
            }

            completeCalibration(calibrationData) {
                if (calibrationData.length === 0) return;
                
                // Calculate noise floor
                const sortedData = calibrationData.sort((a, b) => a - b);
                const noiseFloor = sortedData[Math.floor(sortedData.length * 0.75)]; // 75th percentile
                
                // Set threshold 10dB above noise floor
                this.vadThreshold = Math.max(-60, Math.min(-10, noiseFloor + 10));
                this.vadThresholdSlider.value = this.vadThreshold;
                this.vadValue.textContent = `${this.vadThreshold} dB`;
                
                this.updateSystemStatus(`‚úÖ Calibrated! Noise floor: ${noiseFloor.toFixed(1)}dB`);
            }

            async startAdvancedDetection() {
                try {
                    this.sessionStartTime = new Date();
                    this.updateSystemStatus('üöÄ Initializing advanced audio system...');
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 48000,
                        latencyHint: 'interactive'
                    });
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    await this.addMicrophone();
                    
                    this.isRecording = true;
                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    
                    this.updateButtonStatus('recording');
                    this.startAdvancedAudioProcessing();
                    
                    if (this.recognition) {
                        this.recognition.lang = this.currentLanguage;
                        this.recognition.start();
                    }
                    
                    this.updateSystemStatus('üéØ Advanced detection active');
                    
                } catch (error) {
                    console.error('Error starting advanced detection:', error);
                    this.updateSystemStatus('‚ùå Failed to start detection');
                    this.stopDetection();
                }
            }

            startAdvancedAudioProcessing() {
                this.processingInterval = setInterval(() => {
                    if (!this.isRecording) return;

                    let totalVolume = 0;
                    let activeCount = 0;
                    let dominantFreq = 0;
                    let maxMagnitude = 0;

                    this.speakers.forEach(speaker => {
                        const analyzer = speaker.analyzer;
                        const freqData = new Uint8Array(analyzer.frequencyBinCount);
                        const timeData = new Uint8Array(analyzer.fftSize);
                        
                        analyzer.getByteFrequencyData(freqData);
                        analyzer.getByteTimeDomainData(timeData);
                        
                        // Advanced RMS calculation with noise gating
                        let rms = 0;
                        for (let i = 0; i < timeData.length; i++) {
                            const sample = (timeData[i] - 128) / 128;
                            rms += sample * sample;
                        }
                        rms = Math.sqrt(rms / timeData.length);
                        
                        // Apply noise gate
                        if (rms < this.noiseGate) rms = 0;
                        
                        const db = rms > 0 ? 20 * Math.log10(rms) : -100;
                        speaker.intensity = Math.max(0, Math.min(100, ((db + 60) / 60) * 100));
                        
                        // Advanced Voice Activity Detection with smoothing
                        const isCurrentlyActive = db > this.vadThreshold && rms > (this.noiseGate * this.sensitivity);
                        
                        if (isCurrentlyActive) {
                            speaker.lastActivityTime = Date.now();
                            speaker.isActive = true;
                            activeCount++;
                            totalVolume += speaker.intensity;
                            
                            // Track speaking time
                            if (!this.audioMetrics.speakingTime.has(speaker.id)) {
                                this.audioMetrics.speakingTime.set(speaker.id, 0);
                            }
                            this.audioMetrics.speakingTime.set(
                                speaker.id, 
                                this.audioMetrics.speakingTime.get(speaker.id) + 0.05
                            );
                        } else {
                            speaker.isActive = (Date.now() - speaker.lastActivityTime) < 300;
                        }
                        
                        // Spectral analysis for voice characteristics
                        this.analyzeSpectralFeatures(speaker, freqData);
                        
                        // Find dominant frequency across all speakers
                        for (let i = 0; i < freqData.length; i++) {
                            if (freqData[i] > maxMagnitude) {
                                maxMagnitude = freqData[i];
                                dominantFreq = (i * this.audioContext.sampleRate) / (2 * analyzer.fftSize);
                            }
                        }
                        
                        // Store frequency history for advanced analysis
                        if (!this.frequencyAnalysis.has(speaker.id)) {
                            this.frequencyAnalysis.set(speaker.id, []);
                        }
                        const freqHistory = this.frequencyAnalysis.get(speaker.id);
                        freqHistory.push({
                            timestamp: Date.now(),
                            peakFreq: speaker.peakFrequency,
                            intensity: speaker.intensity,
                            spectralCentroid: this.calculateSpectralCentroid(freqData)
                        });
                        
                        // Keep only recent history
                        if (freqHistory.length > 100) {
                            freqHistory.splice(0, freqHistory.length - 100);
                        }
                    });

                    // Update global metrics
                    this.audioMetrics.averageVolume = activeCount > 0 ? totalVolume / activeCount : 0;
                    this.audioMetrics.dominantFrequency = dominantFreq;

                    this.renderAdvancedSpeakers();
                    this.drawAdvancedVisualization();
                    this.updateAnalytics();
                }, 50);
            }

            analyzeSpectralFeatures(speaker, freqData) {
                // Calculate spectral features for voice identification
                const spectralCentroid = this.calculateSpectralCentroid(freqData);
                const spectralRolloff = this.calculateSpectralRolloff(freqData, 0.85);
                const zeroCrossingRate = this.calculateZeroCrossingRate(speaker);
                
                // Store in speaker profile
                if (!this.speakerProfiles.has(speaker.id)) {
                    this.speakerProfiles.set(speaker.id, {
                        spectralFeatures: [],
                        voiceCharacteristics: {
                            avgPitch: 0,
                            pitchVariability: 0,
                            formantFreqs: [],
                            timbreSignature: []
                        }
                    });
                }
                
                const profile = this.speakerProfiles.get(speaker.id);
                profile.spectralFeatures.push({
                    centroid: spectralCentroid,
                    rolloff: spectralRolloff,
                    zcr: zeroCrossingRate,
                    timestamp: Date.now()
                });
                
                // Keep recent features only
                if (profile.spectralFeatures.length > 50) {
                    profile.spectralFeatures.splice(0, profile.spectralFeatures.length - 50);
                }
                
                // Update speaker characteristics
                speaker.spectralCentroid = spectralCentroid;
                speaker.spectralRolloff = spectralRolloff;
                speaker.zeroCrossingRate = zeroCrossingRate;
            }

            calculateSpectralCentroid(freqData) {
                let weightedSum = 0;
                let magnitudeSum = 0;
                
                for (let i = 1; i < freqData.length; i++) {
                    const freq = (i * this.audioContext.sampleRate) / (2 * freqData.length);
                    weightedSum += freq * freqData[i];
                    magnitudeSum += freqData[i];
                }
                
                return magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
            }

            calculateSpectralRolloff(freqData, threshold) {
                const totalEnergy = freqData.reduce((sum, val) => sum + val * val, 0);
                const rolloffEnergy = totalEnergy * threshold;
                
                let cumulativeEnergy = 0;
                for (let i = 0; i < freqData.length; i++) {
                    cumulativeEnergy += freqData[i] * freqData[i];
                    if (cumulativeEnergy >= rolloffEnergy) {
                        return (i * this.audioContext.sampleRate) / (2 * freqData.length);
                    }
                }
                return 0;
            }

            calculateZeroCrossingRate(speaker) {
                const analyzer = speaker.analyzer;
                const timeData = new Uint8Array(analyzer.fftSize);
                analyzer.getByteTimeDomainData(timeData);
                
                let crossings = 0;
                for (let i = 1; i < timeData.length; i++) {
                    if ((timeData[i] - 128) * (timeData[i-1] - 128) < 0) {
                        crossings++;
                    }
                }
                
                return crossings / timeData.length;
            }

            processAdvancedTranscription(event) {
                let finalTranscript = '';
                let interimTranscript = '';
                let confidence = 0;
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    if (result.isFinal) {
                        finalTranscript += result[0].transcript;
                        confidence = result[0].confidence || 0.8;
                    } else {
                        interimTranscript += result[0].transcript;
                    }
                }
                
                if (finalTranscript.trim()) {
                    this.handleAdvancedTranscription(finalTranscript.trim(), confidence, event);
                }
            }

            handleAdvancedTranscription(text, confidence, event) {
                if (!text || text.length < 2) return;
                
                // Advanced speaker identification using audio characteristics
                const activeSpeakers = Array.from(this.speakers.values())
                    .filter(s => s.isActive)
                    .sort((a, b) => b.intensity - a.intensity);

                let identifiedSpeaker = activeSpeakers[0];
                
                // If multiple active speakers, use spectral analysis for better identification
                if (activeSpeakers.length > 1) {
                    identifiedSpeaker = this.identifySpeakerBySpectralAnalysis(activeSpeakers, text);
                }
                
                if (!identifiedSpeaker) {
                    const recentSpeakers = Array.from(this.speakers.values())
                        .filter(s => (Date.now() - s.lastActivityTime) < 3000)
                        .sort((a, b) => b.intensity - a.intensity);
                    identifiedSpeaker = recentSpeakers[0];
                }
                
                if (!identifiedSpeaker) return;

                // Analyze speech patterns
                const speechPattern = this.analyzeSpeechPattern(text, identifiedSpeaker);
                
                const transcription = {
                    id: Date.now() + Math.random(),
                    speakerId: identifiedSpeaker.id,
                    speakerName: identifiedSpeaker.name,
                    text: text,
                    intensity: identifiedSpeaker.intensity,
                    confidence: confidence,
                    timestamp: new Date(),
                    spectralFeatures: {
                        centroid: identifiedSpeaker.spectralCentroid || 0,
                        rolloff: identifiedSpeaker.spectralRolloff || 0,
                        zcr: identifiedSpeaker.zeroCrossingRate || 0
                    },
                    speechPattern: speechPattern,
                    alternatives: this.extractAlternatives(event),
                    sentiment: this.analyzeSentiment(text),
                    wordCount: text.split(' ').length,
                    duration: this.estimateSpeechDuration(text)
                };

                this.transcriptions.unshift(transcription);
                this.audioMetrics.totalWords += transcription.wordCount;
                
                // Store speech pattern for learning
                this.storeSpeechPattern(identifiedSpeaker.id, speechPattern);
                
                if (this.transcriptions.length > 100) {
                    this.transcriptions = this.transcriptions.slice(0, 100);
                }

                this.renderAdvancedTranscriptions();
                console.log(`Advanced transcription from ${identifiedSpeaker.name}: "${text}" (${(confidence * 100).toFixed(1)}% confidence)`);
            }

            identifySpeakerBySpectralAnalysis(activeSpeakers, text) {
                // Use spectral features and historical patterns to identify speaker
                let bestMatch = activeSpeakers[0];
                let bestScore = -1;
                
                activeSpeakers.forEach(speaker => {
                    let score = speaker.intensity / 100; // Base score from volume
                    
                    // Add spectral consistency score
                    const profile = this.speakerProfiles.get(speaker.id);
                    if (profile && profile.spectralFeatures.length > 5) {
                        const recentFeatures = profile.spectralFeatures.slice(-5);
                        const consistency = this.calculateSpectralConsistency(recentFeatures);
                        score += consistency * 0.3;
                    }
                    
                    // Add speech pattern matching score
                    const patternScore = this.matchSpeechPattern(speaker.id, text);
                    score += patternScore * 0.2;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = speaker;
                    }
                });
                
                return bestMatch;
            }

            calculateSpectralConsistency(features) {
                if (features.length < 2) return 0;
                
                let centroidVariance = 0;
                let rolloffVariance = 0;
                const avgCentroid = features.reduce((sum, f) => sum + f.centroid, 0) / features.length;
                const avgRolloff = features.reduce((sum, f) => sum + f.rolloff, 0) / features.length;
                
                features.forEach(f => {
                    centroidVariance += Math.pow(f.centroid - avgCentroid, 2);
                    rolloffVariance += Math.pow(f.rolloff - avgRolloff, 2);
                });
                
                const consistency = 1 / (1 + Math.sqrt(centroidVariance + rolloffVariance) / features.length);
                return Math.min(1, Math.max(0, consistency));
            }

            analyzeSpeechPattern(text, speaker) {
                const words = text.toLowerCase().split(' ');
                return {
                    wordCount: words.length,
                    avgWordLength: words.reduce((sum, word) => sum + word.length, 0) / words.length,
                    vocabulary: new Set(words).size,
                    speakingRate: this.estimateSpeakingRate(text, speaker),
                    commonWords: this.extractCommonWords(words),
                    sentiment: this.analyzeSentiment(text)
                };
            }

            estimateSpeakingRate(text, speaker) {
                // Estimate words per minute based on intensity patterns
                const wordCount = text.split(' ').length;
                const estimatedDuration = wordCount * 0.6; // Rough estimate: 0.6 seconds per word
                return (wordCount / estimatedDuration) * 60;
            }

            analyzeSentiment(text) {
                // Simple sentiment analysis
                const positiveWords = ['good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic', 'love', 'like', 'happy', 'glad'];
                const negativeWords = ['bad', 'terrible', 'awful', 'hate', 'dislike', 'sad', 'angry', 'frustrated', 'disappointed'];
                
                const words = text.toLowerCase().split(' ');
                let score = 0;
                
                words.forEach(word => {
                    if (positiveWords.includes(word)) score += 1;
                    if (negativeWords.includes(word)) score -= 1;
                });
                
                if (score > 0) return 'positive';
                if (score < 0) return 'negative';
                return 'neutral';
            }

            extractCommonWords(words) {
                const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were']);
                const filtered = words.filter(word => !stopWords.has(word) && word.length > 2);
                const frequency = {};
                
                filtered.forEach(word => {
                    frequency[word] = (frequency[word] || 0) + 1;
                });
                
                return Object.entries(frequency)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .map(([word]) => word);
            }

            storeSpeechPattern(speakerId, pattern) {
                if (!this.speechPatterns.has(speakerId)) {
                    this.speechPatterns.set(speakerId, []);
                }
                
                const patterns = this.speechPatterns.get(speakerId);
                patterns.push(pattern);
                
                if (patterns.length > 20) {
                    patterns.splice(0, patterns.length - 20);
                }
            }

            matchSpeechPattern(speakerId, text) {
                const patterns = this.speechPatterns.get(speakerId);
                if (!patterns || patterns.length < 3) return 0;
                
                const currentPattern = this.analyzeSpeechPattern(text, null);
                let similarity = 0;
                
                patterns.forEach(pattern => {
                    similarity += this.calculatePatternSimilarity(currentPattern, pattern);
                });
                
                return similarity / patterns.length;
            }

            calculatePatternSimilarity(pattern1, pattern2) {
                let score = 0;
                const wordLengthSim = 1 - Math.abs(pattern1.avgWordLength - pattern2.avgWordLength) / Math.max(pattern1.avgWordLength, pattern2.avgWordLength);
                const rateSim = 1 - Math.abs(pattern1.speakingRate - pattern2.speakingRate) / Math.max(pattern1.speakingRate, pattern2.speakingRate);
                
                score = (wordLengthSim + rateSim) / 2;
                return Math.min(1, Math.max(0, score));
            }

            extractAlternatives(event) {
                const alternatives = [];
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    for (let j = 1; j < Math.min(3, result.length); j++) {
                        alternatives.push({
                            text: result[j].transcript,
                            confidence: result[j].confidence || 0
                        });
                    }
                }
                return alternatives;
            }

            estimateSpeechDuration(text) {
                // Rough estimation: average 150 words per minute
                const wordCount = text.split(' ').length;
                return (wordCount / 150) * 60; // in seconds
            }

            drawAdvancedVisualization() {
                const canvas = this.audioCanvas;
                const ctx = this.canvasCtx;
                const width = canvas.width;
                const height = canvas.height;

                // Create animated gradient background
                const time = Date.now() * 0.001;
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, `hsla(${(time * 20) % 360}, 70%, 15%, 1)`);
                gradient.addColorStop(0.5, `hsla(${(time * 30 + 120) % 360}, 60%, 10%, 1)`);
                gradient.addColorStop(1, `hsla(${(time * 25 + 240) % 360}, 80%, 8%, 1)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                const speakersArray = Array.from(this.speakers.values());
                if (speakersArray.length === 0) {
                    this.drawNoAudioMessage(ctx, width, height);
                    return;
                }

                const sectionWidth = width / speakersArray.length;

                speakersArray.forEach((speaker, index) => {
                    const x = index * sectionWidth;
                    this.drawSpeakerVisualization(ctx, speaker, x, sectionWidth, height, time);
                });

                // Draw global frequency spectrum
                this.drawGlobalSpectrum(ctx, width, height);
                
                // Draw real-time analytics overlay
                this.drawAnalyticsOverlay(ctx, width, height);
            }

            drawSpeakerVisualization(ctx, speaker, x, width, height, time) {
                const analyzer = speaker.analyzer;
                const freqData = new Uint8Array(analyzer.frequencyBinCount);
                analyzer.getByteFrequencyData(freqData);
                
                // Main intensity visualization
                const centerX = x + width / 2;
                const centerY = height / 2;
                const maxRadius = Math.min(width, height) * 0.15;
                const currentRadius = (speaker.intensity / 100) * maxRadius;
                
                // Pulsing circle for active speaker
                if (speaker.isActive) {
                    const pulseRadius = currentRadius + Math.sin(time * 8) * 10;
                    
                    // Outer glow
                    const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, pulseRadius + 20);
                    glowGradient.addColorStop(0, `${speaker.color}88`);
                    glowGradient.addColorStop(1, `${speaker.color}00`);
                    ctx.fillStyle = glowGradient;
                    ctx.fillRect(x, 0, width, height);
                    
                    // Main circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, pulseRadius, 0, 2 * Math.PI);
                    const circleGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, pulseRadius);
                    circleGradient.addColorStop(0, speaker.color);
                    circleGradient.addColorStop(0.7, `${speaker.color}AA`);
                    circleGradient.addColorStop(1, `${speaker.color}22`);
                    ctx.fillStyle = circleGradient;
                    ctx.fill();
                }
                
                // Frequency bars around the circle
                const barCount = 32;
                const angleStep = (2 * Math.PI) / barCount;
                
                for (let i = 0; i < barCount; i++) {
                    const dataIndex = Math.floor((i * freqData.length) / barCount);
                    const magnitude = freqData[dataIndex] / 255;
                    const angle = i * angleStep;
                    
                    const innerRadius = currentRadius + 10;
                    const barLength = magnitude * 40;
                    
                    const startX = centerX + Math.cos(angle) * innerRadius;
                    const startY = centerY + Math.sin(angle) * innerRadius;
                    const endX = centerX + Math.cos(angle) * (innerRadius + barLength);
                    const endY = centerY + Math.sin(angle) * (innerRadius + barLength);
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = speaker.isActive ? `${speaker.color}CC` : `${speaker.color}44`;
                    ctx.stroke();
                }
                
                // Speaker info
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(speaker.name, centerX, height - 60);
                
                ctx.font = '12px Arial';
                ctx.fillStyle = '#cccccc';
                ctx.fillText(`${speaker.intensity.toFixed(1)}%`, centerX, height - 40);
                
                if (speaker.spectralCentroid) {
                    ctx.fillText(`${Math.round(speaker.spectralCentroid)}Hz`, centerX, height - 25);
                }
                
                // Activity indicator
                if (speaker.isActive) {
                    ctx.beginPath();
                    ctx.arc(centerX + width * 0.3, 30, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fill();
                    
                    // Animated ring
                    ctx.beginPath();
                    ctx.arc(centerX + width * 0.3, 30, 10 + Math.sin(time * 6) * 2, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.7;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }

            drawNoAudioMessage(ctx, width, height) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üé§ No Active Microphones', width / 2, height / 2);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillText('Add microphones to see advanced visualizations', width / 2, height / 2 + 30);
            }

            drawGlobalSpectrum(ctx, width, height) {
                if (this.speakers.size === 0) return;
                
                // Combine all frequency data
                const combinedFreqData = new Array(256).fill(0);
                let activeAnalyzers = 0;
                
                this.speakers.forEach(speaker => {
                    if (speaker.isActive) {
                        const freqData = new Uint8Array(speaker.analyzer.frequencyBinCount);
                        speaker.analyzer.getByteFrequencyData(freqData);
                        
                        for (let i = 0; i < Math.min(256, freqData.length); i++) {
                            combinedFreqData[i] += freqData[i];
                        }
                        activeAnalyzers++;
                    }
                });
                
                if (activeAnalyzers === 0) return;
                
                // Average the data
                for (let i = 0; i < combinedFreqData.length; i++) {
                    combinedFreqData[i] /= activeAnalyzers;
                }
                
                // Draw spectrum at the bottom
                const spectrumHeight = 60;
                const startY = height - spectrumHeight - 10;
                const barWidth = width / combinedFreqData.length;
                
                ctx.globalAlpha = 0.8;
                for (let i = 0; i < combinedFreqData.length; i++) {
                    const barHeight = (combinedFreqData[i] / 255) * spectrumHeight;
                    const hue = (i / combinedFreqData.length) * 360;
                    
                    ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                    ctx.fillRect(i * barWidth, startY + spectrumHeight - barHeight, barWidth - 1, barHeight);
                }
                ctx.globalAlpha = 1;
            }

            drawAnalyticsOverlay(ctx, width, height) {
                // Semi-transparent overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(10, 10, 200, 80);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                
                ctx.fillText(`Active: ${Array.from(this.speakers.values()).filter(s => s.isActive).length}`, 20, 30);
                ctx.fillText(`Avg Vol: ${this.audioMetrics.averageVolume.toFixed(1)}%`, 20, 45);
                ctx.fillText(`Dom Freq: ${Math.round(this.audioMetrics.dominantFrequency)}Hz`, 20, 60);
                ctx.fillText(`Words: ${this.audioMetrics.totalWords}`, 20, 75);
            }

            renderAdvancedSpeakers() {
                const rankedSpeakers = Array.from(this.speakers.values())
                    .sort((a, b) => b.intensity - a.intensity);

                if (rankedSpeakers.length === 0) {
                    this.speakersList.innerHTML = '<div class="no-data">No microphones connected</div>';
                    return;
                }

                this.speakersList.innerHTML = rankedSpeakers.map((speaker, index) => {
                    const isActive = speaker.isActive;
                    const rank = Array.from(this.speakers.values()).filter(s => s.isActive && s.intensity >= speaker.intensity).length;
                    const speakingTime = this.audioMetrics.speakingTime.get(speaker.id) || 0;
                    
                    return `
                        <div class="speaker-item ${isActive ? 'active' : ''}">
                            <div class="speaker-header">
                                <div style="display: flex; align-items: center;">
                                    <div class="speaker-avatar" style="background: ${speaker.color}">
                                        ${speaker.name.charAt(0).toUpperCase()}
                                    </div>
                                    <div class="speaker-name">
                                        ${speaker.name}
                                        ${isActive && rank === 1 ? ' üëë' : ''}
                                    </div>
                                </div>
                                <div class="speaker-controls">
                                    <button class="btn btn-small" onclick="speakerSystem.removeMicrophone(${speaker.id})">Remove</button>
                                </div>
                            </div>
                            
                            <div class="intensity-bar">
                                <div class="intensity-fill" style="width: ${speaker.intensity}%"></div>
                            </div>
                            
                            <div class="spectral-analysis">
                                <div class="frequency-band">
                                    <div class="frequency-label">Intensity</div>
                                    <div class="frequency-value">${speaker.intensity.toFixed(1)}%</div>
                                </div>
                                <div class="frequency-band">
                                    <div class="frequency-label">Centroid</div>
                                    <div class="frequency-value">${Math.round(speaker.spectralCentroid || 0)}Hz</div>
                                </div>
                                <div class="frequency-band">
                                    <div class="frequency-label">Rolloff</div>
                                    <div class="frequency-value">${Math.round(speaker.spectralRolloff || 0)}Hz</div>
                                </div>
                                <div class="frequency-band">
                                    <div class="frequency-label">Speaking</div>
                                    <div class="frequency-value">${speakingTime.toFixed(1)}s</div>
                                </div>
                            </div>
                            
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #ccc;">
                                Status: ${isActive ? `üéôÔ∏è Speaking (Rank #${rank})` : 'üîá Silent'} | 
                                ZCR: ${(speaker.zeroCrossingRate || 0).toFixed(3)}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            renderAdvancedTranscriptions() {
                if (this.transcriptions.length === 0) {
                    this.transcriptionsList.innerHTML = '<div class="no-data">Start speaking to see live transcriptions...</div>';
                    return;
                }

                const sortedTranscriptions = [...this.transcriptions]
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, 50); // Show only recent 50

                this.transcriptionsList.innerHTML = sortedTranscriptions.map((transcription, index) => {
                    const speaker = this.speakers.get(transcription.speakerId);
                    const timeAgo = this.getTimeAgo(transcription.timestamp);
                    const confidenceColor = transcription.confidence > 0.8 ? '#4CAF50' : 
                                          transcription.confidence > 0.6 ? '#FF9800' : '#f44336';
                    
                    return `
                        <div class="transcription-item ${transcription.confidence > 0.7 ? 'closest' : ''}">
                            <div class="transcription-header">
                                <div class="transcription-speaker">
                                    <span style="color: ${speaker ? speaker.color : '#666'}">‚óè</span>
                                    ${transcription.speakerName}
                                </div>
                                <div class="transcription-rank" style="color: ${confidenceColor}">
                                    ${Math.round(transcription.confidence * 100)}% confidence
                                </div>
                            </div>
                            <div class="transcription-text">"${transcription.text}"</div>
                            <div class="transcription-meta">
                                <div>
                                    <span>Words: ${transcription.wordCount}</span> |
                                    <span>Sentiment: ${transcription.sentiment}</span> |
                                    <span>Intensity: ${transcription.intensity.toFixed(1)}%</span>
                                </div>
                                <div>
                                    <span>${timeAgo}</span>
                                </div>
                            </div>
                            ${transcription.alternatives && transcription.alternatives.length > 0 ? `
                                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #888;">
                                    Alternatives: ${transcription.alternatives.slice(0, 2).map(alt => 
                                        `"${alt.text}" (${Math.round(alt.confidence * 100)}%)`
                                    ).join(', ')}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            }

            updateAnalytics() {
                const activeSpeakers = Array.from(this.speakers.values()).filter(s => s.isActive);
                this.totalSpeakersEl.textContent = activeSpeakers.length;
                this.totalTranscriptionsEl.textContent = this.transcriptions.length;
                this.avgVolumeEl.textContent = `${this.audioMetrics.averageVolume.toFixed(1)}%`;
                this.dominantFreqEl.textContent = `${Math.round(this.audioMetrics.dominantFrequency)}Hz`;
            }

            startAnalyticsUpdate() {
                setInterval(() => {
                    if (this.isRecording) {
                        this.updateAnalytics();
                    }
                }, 1000);
            }

            async loadAudioDevices() {
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                        stream.getTracks().forEach(track => track.stop());
                    });
                    
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.availableDevices = devices.filter(device => device.kind === 'audioinput');
                    this.renderDevicesList();
                    
                    console.log(`Found ${this.availableDevices.length} audio input devices`);
                } catch (error) {
                    console.error('Error loading audio devices:', error);
                    this.devicesList.innerHTML = '<p class="no-data">Unable to load audio devices</p>';
                }
            }

            renderDevicesList() {
                if (this.availableDevices.length === 0) {
                    this.devicesList.innerHTML = '<div class="no-data">No audio devices found</div>';
                    return;
                }

                this.devicesList.innerHTML = this.availableDevices.map((device, index) => {
                    const isInUse = Array.from(this.speakers.values()).some(speaker => 
                        speaker.deviceId === device.deviceId
                    );
                    
                    return `
                        <div class="device-item ${isInUse ? 'in-use' : ''}">
                            <div>
                                <div class="device-name">
                                    üé§ ${device.label || `Microphone ${index + 1}`}
                                </div>
                                <div style="font-size: 0.8rem; color: #888;">
                                    ${device.deviceId.substring(0, 20)}...
                                </div>
                            </div>
                            <button class="btn btn-small" 
                                    onclick="speakerSystem.addSpecificMicrophone('${device.deviceId}', '${device.label || `Mic ${index + 1}`}')"
                                    ${isInUse ? 'disabled' : ''}>
                                ${isInUse ? '‚úì Added' : '+ Add'}
                            </button>
                        </div>
                    `;
                }).join('');
            }

            async addMicrophone() {
                try {
                    this.updateSystemStatus('üé§ Adding default microphone...');
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000,
                            channelCount: 1
                        }
                    });
                    
                    await this.processMicrophoneStream(stream, 'Default Microphone', 'default');
                    this.updateSystemStatus('‚úÖ Default microphone added');
                } catch (error) {
                    console.error('Error adding microphone:', error);
                    this.updateSystemStatus('‚ùå Failed to add microphone');
                    throw error;
                }
            }

            async addSpecificMicrophone(deviceId, deviceName) {
                try {
                    this.updateSystemStatus(`üé§ Adding ${deviceName}...`);
                    
                    const existingSpeaker = Array.from(this.speakers.values()).find(s => s.deviceId === deviceId);
                    if (existingSpeaker) {
                        alert('This device is already in use!');
                        return;
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            deviceId: { exact: deviceId },
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000,
                            channelCount: 1
                        }
                    });
                    
                    await this.processMicrophoneStream(stream, deviceName, deviceId);
                    this.updateSystemStatus(`‚úÖ ${deviceName} added`);
                    this.renderDevicesList();
                } catch (error) {
                    console.error('Error adding specific microphone:', error);
                    this.updateSystemStatus(`‚ùå Failed to add ${deviceName}`);
                    alert(`Could not access ${deviceName}. Please check permissions.`);
                }
            }

            async processMicrophoneStream(stream, name, deviceId) {
                const speakerId = this.speakerId++;
                
                try {
                    const source = this.audioContext.createMediaStreamSource(stream);
                    const analyzer = this.audioContext.createAnalyser();
                    
                    analyzer.fftSize = 4096;
                    analyzer.smoothingTimeConstant = 0.8;
                    analyzer.minDecibels = -90;
                    analyzer.maxDecibels = -10;
                    
                    source.connect(analyzer);
                    
                    const speaker = {
                        id: speakerId,
                        name: name,
                        deviceId: deviceId,
                        stream: stream,
                        source: source,
                        analyzer: analyzer,
                        intensity: 0,
                        isActive: false,
                        rmsHistory: [],
                        peakFrequency: 0,
                        spectralCentroid: 0,
                        spectralRolloff: 0,
                        zeroCrossingRate: 0,
                        color: this.generateAdvancedColor(speakerId),
                        lastActivityTime: 0
                    };

                    this.speakers.set(speakerId, speaker);
                    this.audioAnalyzers.set(speakerId, analyzer);
                    this.renderAdvancedSpeakers();
                    
                    console.log(`Added advanced microphone: ${name} (ID: ${speakerId})`);
                    
                } catch (error) {
                    console.error('Error processing microphone stream:', error);
                    stream.getTracks().forEach(track => track.stop());
                    throw error;
                }
            }

            generateAdvancedColor(id) {
                const colors = [
                    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',
                    '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43',
                    '#6C5CE7', '#A29BFE', '#FD79A8', '#E17055', '#81ECEC'
                ];
                return colors[id % colors.length];
            }

            exportSessionData() {
                const sessionData = {
                    sessionInfo: {
                        startTime: this.sessionStartTime,
                        endTime: new Date(),
                        duration: this.sessionStartTime ? (Date.now() - this.sessionStartTime.getTime()) / 1000 : 0
                    },
                    speakers: Array.from(this.speakers.values()).map(speaker => ({
                        id: speaker.id,
                        name: speaker.name,
                        deviceId: speaker.deviceId,
                        totalSpeakingTime: this.audioMetrics.speakingTime.get(speaker.id) || 0,
                        averageIntensity: speaker.intensity
                    })),
                    transcriptions: this.transcriptions.map(t => ({
                        timestamp: t.timestamp,
                        speaker: t.speakerName,
                        text: t.text,
                        confidence: t.confidence,
                        sentiment: t.sentiment,
                        wordCount: t.wordCount
                    })),
                    analytics: {
                        totalWords: this.audioMetrics.totalWords,
                        averageVolume: this.audioMetrics.averageVolume,
                        dominantFrequency: this.audioMetrics.dominantFrequency
                    },
                    speechPatterns: Object.fromEntries(this.speechPatterns),
                    frequencyAnalysis: Object.fromEntries(this.frequencyAnalysis)
                };

                const blob = new Blob([JSON.stringify(sessionData, null, 2)], { 
                    type: 'application/json' 
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `speaker-session-${new Date().toISOString().slice(0, 19)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateSystemStatus('üìä Session data exported');
            }

            resetSystem() {
                if (confirm('Reset all data and stop detection?')) {
                    this.stopDetection();
                    this.transcriptions = [];
                    this.speechPatterns.clear();
                    this.frequencyAnalysis.clear();
                    this.speakerProfiles.clear();
                    this.audioMetrics = {
                        totalWords: 0,
                        averageVolume: 0,
                        dominantFrequency: 0,
                        speakingTime: new Map()
                    };
                    
                    this.renderAdvancedTranscriptions();
                    this.updateAnalytics();
                    this.updateSystemStatus('üîÑ System reset');
                }
            }

            removeMicrophone(speakerId) {
                const speaker = this.speakers.get(speakerId);
                if (speaker) {
                    speaker.stream.getTracks().forEach(track => track.stop());
                    speaker.source.disconnect();
                    
                    this.speakers.delete(speakerId);
                    this.audioAnalyzers.delete(speakerId);
                    this.speechPatterns.delete(speakerId);
                    this.frequencyAnalysis.delete(speakerId);
                    this.speakerProfiles.delete(speakerId);
                    
                    this.renderAdvancedSpeakers();
                    this.renderDevicesList();
                    
                    this.updateSystemStatus(`üóëÔ∏è Removed: ${speaker.name}`);
                }
            }

            restartSpeechRecognition() {
                if (this.recognition && this.isTranscribing) {
                    this.recognition.stop();
                    setTimeout(() => {
                        this.recognition.lang = this.currentLanguage;
                        this.recognition.start();
                    }, 500);
                }
            }

            stopDetection() {
                this.isRecording = false;
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                
                this.speakers.forEach(speaker => {
                    speaker.stream.getTracks().forEach(track => track.stop());
                    speaker.source.disconnect();
                });
                
                this.speakers.clear();
                this.audioAnalyzers.clear();
                
                if (this.recognition && this.isTranscribing) {
                    this.recognition.stop();
                    this.isTranscribing = false;
                }
                
                if (this.audioContext && this.audioContext.state !== 'closed') {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                this.updateButtonStatus('idle');
                this.clearIntervals();
                
                this.speakersList.innerHTML = '<div class="no-data">Detection stopped</div>';
                
                const ctx = this.canvasCtx;
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, this.audioCanvas.width, this.audioCanvas.height);
                
                this.renderDevicesList();
                this.updateSystemStatus('‚èπÔ∏è Advanced detection stopped');
            }

            updateButtonStatus(status) {
                const indicators = document.querySelectorAll('.status-indicator');
                indicators.forEach(indicator => {
                    indicator.className = `status-indicator ${status}`;
                });
            }

            updateSystemStatus(message) {
                const statusText = this.systemStatus.querySelector('span:not(.status-indicator)');
                if (statusText) {
                    statusText.textContent = message;
                }
                console.log(`Advanced System: ${message}`);
            }

            getTimeAgo(timestamp) {
                const seconds = Math.floor((Date.now() - timestamp.getTime()) / 1000);
                if (seconds < 60) return `${seconds}s ago`;
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                return `${hours}h ago`;
            }

            clearIntervals() {
                if (this.processingInterval) {
                    clearInterval(this.processingInterval);
                    this.processingInterval = null;
                }
                if (this.transcriptionTimeout) {
                    clearTimeout(this.transcriptionTimeout);
                    this.transcriptionTimeout = null;
                }
            }

            getAdvancedSystemInfo() {
                return {
                    isRecording: this.isRecording,
                    speakerCount: this.speakers.size,
                    transcriptionCount: this.transcriptions.length,
                    audioContextState: this.audioContext ? this.audioContext.state : 'null',
                    speechRecognitionSupported: !!this.recognition,
                    currentLanguage: this.currentLanguage,
                    sessionDuration: this.sessionStartTime ? (Date.now() - this.sessionStartTime.getTime()) / 1000 : 0,
                    totalWords: this.audioMetrics.totalWords,
                    speechPatternsLearned: this.speechPatterns.size,
                    speakerProfilesBuilt: this.speakerProfiles.size
                };
            }
        }

        // Initialize the advanced system
        let speakerSystem;
        document.addEventListener('DOMContentLoaded', () => {
            speakerSystem = new AdvancedSpeakerDetectionSystem();
            window.speakerSystem = speakerSystem;
            
            window.addEventListener('error', (event) => {
                console.error('Global error:', event.error);
                if (speakerSystem) {
                    speakerSystem.updateSystemStatus('‚ùå System error occurred');
                }
            });
            
            console.log('üöÄ Advanced Real-Time Speaker Detection System initialized');
        });
    </script>
</body>
</html>